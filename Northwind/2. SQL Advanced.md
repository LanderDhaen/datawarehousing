## Simple & Correlated Subqueries

1. Give the id and name of the products that have not been purchased yet.

```sql
SELECT p.productID, p.productName
FROM Products p
WHERE p.ProductID NOT IN (
						  SELECT od.productID
						  FROM OrderDetails od
						  )
```

2. Select the names of the suppliers who supply products that have not been ordered yet.

```sql
SELECT s.CompanyName
FROM Suppliers s
JOIN Products p ON s.SupplierID = p.SupplierID
WHERE p.ProductID NOT IN (
						  SELECT od.ProductID
						  FROM OrderDetails od
						  )
```

3. Give a list of all customers from the same country as the customer Maison Dewey

```sql
SELECT *
FROM Customers c
WHERE c.Country = (
				   SELECT inner_c.Country
				   FROM Customers inner_c
				   WHERE inner_c.CompanyName = 'Maison Dewey'
				   )
```

4. Give for each product how much the price differs from the average price of all products of the same category

```sql
SELECT p.ProductID, p.ProductName, p.UnitPrice, UnitPrice
- (
   SELECT AVG(inner_p.UnitPrice)
   FROM Products inner_p
   WHERE inner_p.CategoryID = p.CategoryID
   ) AS Difference
FROM Products p
```

5. Give per title the employee that was last hired

```sql
SELECT e.Title, e.LastName, e.FirstName, e.HireDate
FROM Employees e
WHERE e.HireDate = (
					SELECT MAX(inner_e.HireDate)
					FROM Employees inner_e
					WHERE inner_e.Title = e.Title
					)
```

6. Which employee has processed most orders?

```sql
SELECT TOP 1 e.LastName, e.FirstName, (SELECT COUNT(o.OrderID) FROM Orders o WHERE o.EmployeeID = e.EmployeeID) AS 'Orders'
FROM Employees e
ORDER BY (
          SELECT COUNT(o.OrderID)
		  FROM Orders o
		  WHERE o.EmployeeID = e.EmployeeID
		  ) DESC
```

7. What's the most common ContactTitle in Customers?

```sql
SELECT TOP 1 c.ContactTitle, COUNT(c.ContactTitle) AS 'Amount'
FROM Customers c
GROUP BY c.ContactTitle
ORDER BY COUNT(c.ContactTitle) DESC
```

8. Is there a supplier that has the same name as a customer?

```sql
SELECT s.CompanyName
FROM Suppliers s
WHERE s.CompanyName IN (
						SELECT c.CompanyName
						FROM Customers c
						)
```

9. Give all the orders for which the ShipAddressis different from the CustomerAddress,

```sql
SELECT *
FROM Orders o
WHERE o.ShipAddress != (
						SELECT c.Address
						FROM Customers c
						WHERE o.CustomerID = c.CustomerID
						)
```

## Views

1. The company wants to weekly check the stock of their products. If the stock is below 15, they'd like to order more to fulfill the need.

```sql
-- Create a QUERY that shows the ProductId, ProductName and the name of the supplier, do not forget the WHERE clause.

SELECT p.ProductID, p.ProductName, s.CompanyName
FROM Products p
JOIN Suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock < 15

-- Turn this SELECT statement into a VIEW called: vw_products_to_order.

CREATE VIEW vw_products_to_order AS
SELECT p.ProductID, p.ProductName, s.CompanyName
FROM Products p
JOIN Suppliers s ON p.SupplierID = s.SupplierID
WHERE p.UnitsInStock < 15

-- Query the VIEW to see the results.

SELECT * FROM vw_products_to_order
```

2. The company has to increase prices of certain products. To make it seem the prices are not increasing dramatically they're planning to spread the price increase over multiple years. In total they'd like a 10% price for certain products. The list of impacted products can grow over the coming years. We'd like to keep all the logic of selecting the correct products in 1 SQL View, in programming terms 'keeping it DRY'. The updating of the items is not part of the view itself. The products in scope are all the products with the term 'Bröd' or 'Biscuit'.

```sql
-- Create a simple SQL Query to get the correct resultset

SELECT \*
FROM Products p
WHERE p.ProductName LIKE '%bröd%' OR p.ProductName = '%biscuit%'

-- Turn this SELECT statement into a VIEW called: vw_price_increasing_products.

CREATE VIEW vw_price_increasing_products AS
SELECT \*
FROM Products p
WHERE p.ProductName LIKE '%bröd%' OR p.ProductName = '%biscuit%'

-- Query the VIEW to see the results.

SELECT \* FROM vw_price_increasing_products
```

## Common Table Expressions

1. Give all employees that started working as an employee in the same year as Robert King

```sql
WITH HireYearRB AS (
	SELECT YEAR(e.HireDate) AS HireYear
	FROM Employees e
	WHERE e.FirstName = 'Robert' AND e.LastName = 'King'
)

SELECT *
FROM Employees e
JOIN HireYearRB h ON YEAR(e.HireDate) = h.HireYear
WHERE NOT(FirstName = 'Robert' AND LastName = 'King')
```

2 Make a histogram of the number of orders per customer, so show how many times each number occurs.

```sql
WITH AmountOfOrders AS (
	SELECT COUNT(*) AS Amount
	FROM Orders o
	GROUP BY o.CustomerID
	)

SELECT COUNT(*) AS 'Customers',  a.Amount AS 'Orders'
FROM AmountOfOrders a
GROUP BY a.Amount
ORDER BY a.Amount
```

3. Give the customers of the Country in which most customers live

```sql
WITH CustomersPerCountry AS
	(
	SELECT c.Country, COUNT(c.CustomerID) AS Amount
	FROM Customers c
	GROUP BY c.Country
	),

MaximumAmount AS
	(
	SELECT MAX(cpc.Amount) AS Maximum
	FROM CustomersPerCountry cpc
	)

SELECT *
FROM Customers c
JOIN CustomersPerCountry cpc ON c.Country = cpc.Country
JOIN MaximumAmount ma ON cpc.Amount = ma.Maximum
```

4. Give all employees except for the eldest. Solve this first using a subquery and afterwards using a cte

```sql
-- Subquery

SELECT *
FROM Employees e
WHERE e.BirthDate != (
					  SELECT MIN(e.BirthDate)
					  FROM Employees e
					  )

-- CTE

WITH OldestEmployee AS (
	SELECT MIN(e.BirthDate) AS BirthDate
	FROM Employees e
	)

SELECT *
FROM Employees e
CROSS JOIN OldestEmployee oe
WHERE e.BirthDate > oe.BirthDate
```

5. What is the total number of customers and suppliers?

```sql
WITH AmountOfCustomers AS (
	SELECT COUNT(*) AS Amount
	FROM Customers c
	),

AmountOfSuppliers AS (
	SELECT COUNT(*) AS Amount
	FROM Suppliers s
	)

SELECT aoc.Amount + aos.Amount AS 'Total'
FROM AmountOfCustomers aoc
CROSS JOIN AmountOfSuppliers aos
```

6. Give per title the eldest employee

```sql
WITH OldestEmployee AS (
	SELECT e.Title, MIN(e.BirthDate) AS BirthDate
	FROM Employees e
	GROUP BY e.Title
	)

SELECT e.Title, e.FirstName, e.LastName, e.BirthDate
FROM Employees e
JOIN OldestEmployee oe
ON e.BirthDate = oe.BirthDate AND e.Title = oe.Title
```

7. Give per title the employee that earns most

```sql
WITH HighestSalaryEmployee AS (
	SELECT e.Title, MAX(e.Salary) AS Salary
	FROM Employees e
	GROUP BY e.Title
	)

SELECT e.Title, e.FirstName, e.LastName, e.Salary
FROM Employees e
JOIN HighestSalaryEmployee hse
ON e.Salary = hse.Salary AND e.Title = hse.Salary
```

8. Give the titles for which the eldest employee is also the employee who earns most

```sql
WITH OldestEmployee AS (
	SELECT e.Title, MIN(e.BirthDate) AS BirthDate
	FROM Employees e
	GROUP BY e.Title
	),

HighestSalaryEmployee AS (
	SELECT e.Title, MAX(e.Salary) AS Salary
	FROM Employees e
	GROUP BY e.Title
	)

SELECT e.Title, e.FirstName, e.LastName, e.BirthDate, e.Salary
FROM Employees e
JOIN OldestEmployee oe ON e.BirthDate = oe.BirthDate AND e.Title = oe.Title
JOIN HighestSalaryEmployee hse ON e.Salary = hse.Salary AND e.Title = hse.Title
```

9. Execute the following script:

```sql
CREATE TABLE Parts
(
    [Super]   CHAR(3) NOT NULL,
    [Sub]     CHAR(3) NOT NULL,
    [Amount]  INT NOT NULL,
    PRIMARY KEY(Super, Sub)
);

INSERT INTO Parts VALUES ('O1','O2',10);
INSERT INTO Parts VALUES ('O1','O3',5);
INSERT INTO Parts VALUES ('O1','O4',10);
INSERT INTO Parts VALUES ('O2','O5',25);
INSERT INTO Parts VALUES ('O2','O6',5);
INSERT INTO Parts VALUES ('O3','O7',10);
INSERT INTO Parts VALUES ('O6','O8',15);
INSERT INTO Parts VALUES ('O8','O11',5);
INSERT INTO Parts VALUES ('O9','O10',20);
INSERT INTO Parts VALUES ('O10','O11',25);

-- Show all parts that are directly or indirectly part of O2, so all parts of which O2 is composed.
-- Add an extra column with the path as below:

WITH Relation(Super, Sub, [Path]) AS 
    (
        SELECT Super, Sub, [Path] = CAST(CONCAT(Super, ' <- ',Sub) AS NVARCHAR(MAX))
        FROM Parts 
        WHERE Super = 'O2' 

        UNION ALL

        SELECT Parts.Super, Parts.Sub, [Path] = CONCAT(Relation.[Path], ' <- ',Parts.Sub)
        FROM Parts 
        JOIN Relation ON Parts.Super = Relation.Sub
    )

    SELECT * FROM Relation;
```
